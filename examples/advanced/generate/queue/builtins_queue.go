// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package queue

type (
	BoolQueue struct {
		items []bool
	}
)

//noinspection GoUnusedExportedFunction
func NewBoolQueue() *BoolQueue {
	q := new(BoolQueue)
	q.items = make([]bool, 0, 0)
	return q
}

func (q *BoolQueue) Count() int {
	return len(q.items)
}

func (q *BoolQueue) Enqueue(v bool) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *BoolQueue) Dequeue() (v bool, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	ByteQueue struct {
		items []byte
	}
)

//noinspection GoUnusedExportedFunction
func NewByteQueue() *ByteQueue {
	q := new(ByteQueue)
	q.items = make([]byte, 0, 0)
	return q
}

func (q *ByteQueue) Count() int {
	return len(q.items)
}

func (q *ByteQueue) Enqueue(v byte) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *ByteQueue) Dequeue() (v byte, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Complex128Queue struct {
		items []complex128
	}
)

//noinspection GoUnusedExportedFunction
func NewComplex128Queue() *Complex128Queue {
	q := new(Complex128Queue)
	q.items = make([]complex128, 0, 0)
	return q
}

func (q *Complex128Queue) Count() int {
	return len(q.items)
}

func (q *Complex128Queue) Enqueue(v complex128) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Complex128Queue) Dequeue() (v complex128, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Complex64Queue struct {
		items []complex64
	}
)

//noinspection GoUnusedExportedFunction
func NewComplex64Queue() *Complex64Queue {
	q := new(Complex64Queue)
	q.items = make([]complex64, 0, 0)
	return q
}

func (q *Complex64Queue) Count() int {
	return len(q.items)
}

func (q *Complex64Queue) Enqueue(v complex64) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Complex64Queue) Dequeue() (v complex64, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	ErrorQueue struct {
		items []error
	}
)

//noinspection GoUnusedExportedFunction
func NewErrorQueue() *ErrorQueue {
	q := new(ErrorQueue)
	q.items = make([]error, 0, 0)
	return q
}

func (q *ErrorQueue) Count() int {
	return len(q.items)
}

func (q *ErrorQueue) Enqueue(v error) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *ErrorQueue) Dequeue() (v error, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Float32Queue struct {
		items []float32
	}
)

//noinspection GoUnusedExportedFunction
func NewFloat32Queue() *Float32Queue {
	q := new(Float32Queue)
	q.items = make([]float32, 0, 0)
	return q
}

func (q *Float32Queue) Count() int {
	return len(q.items)
}

func (q *Float32Queue) Enqueue(v float32) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Float32Queue) Dequeue() (v float32, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Float64Queue struct {
		items []float64
	}
)

//noinspection GoUnusedExportedFunction
func NewFloat64Queue() *Float64Queue {
	q := new(Float64Queue)
	q.items = make([]float64, 0, 0)
	return q
}

func (q *Float64Queue) Count() int {
	return len(q.items)
}

func (q *Float64Queue) Enqueue(v float64) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Float64Queue) Dequeue() (v float64, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	IntQueue struct {
		items []int
	}
)

//noinspection GoUnusedExportedFunction
func NewIntQueue() *IntQueue {
	q := new(IntQueue)
	q.items = make([]int, 0, 0)
	return q
}

func (q *IntQueue) Count() int {
	return len(q.items)
}

func (q *IntQueue) Enqueue(v int) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *IntQueue) Dequeue() (v int, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Int16Queue struct {
		items []int16
	}
)

//noinspection GoUnusedExportedFunction
func NewInt16Queue() *Int16Queue {
	q := new(Int16Queue)
	q.items = make([]int16, 0, 0)
	return q
}

func (q *Int16Queue) Count() int {
	return len(q.items)
}

func (q *Int16Queue) Enqueue(v int16) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Int16Queue) Dequeue() (v int16, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Int32Queue struct {
		items []int32
	}
)

//noinspection GoUnusedExportedFunction
func NewInt32Queue() *Int32Queue {
	q := new(Int32Queue)
	q.items = make([]int32, 0, 0)
	return q
}

func (q *Int32Queue) Count() int {
	return len(q.items)
}

func (q *Int32Queue) Enqueue(v int32) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Int32Queue) Dequeue() (v int32, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Int64Queue struct {
		items []int64
	}
)

//noinspection GoUnusedExportedFunction
func NewInt64Queue() *Int64Queue {
	q := new(Int64Queue)
	q.items = make([]int64, 0, 0)
	return q
}

func (q *Int64Queue) Count() int {
	return len(q.items)
}

func (q *Int64Queue) Enqueue(v int64) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Int64Queue) Dequeue() (v int64, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Int8Queue struct {
		items []int8
	}
)

//noinspection GoUnusedExportedFunction
func NewInt8Queue() *Int8Queue {
	q := new(Int8Queue)
	q.items = make([]int8, 0, 0)
	return q
}

func (q *Int8Queue) Count() int {
	return len(q.items)
}

func (q *Int8Queue) Enqueue(v int8) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Int8Queue) Dequeue() (v int8, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	RuneQueue struct {
		items []rune
	}
)

//noinspection GoUnusedExportedFunction
func NewRuneQueue() *RuneQueue {
	q := new(RuneQueue)
	q.items = make([]rune, 0, 0)
	return q
}

func (q *RuneQueue) Count() int {
	return len(q.items)
}

func (q *RuneQueue) Enqueue(v rune) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *RuneQueue) Dequeue() (v rune, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	StringQueue struct {
		items []string
	}
)

//noinspection GoUnusedExportedFunction
func NewStringQueue() *StringQueue {
	q := new(StringQueue)
	q.items = make([]string, 0, 0)
	return q
}

func (q *StringQueue) Count() int {
	return len(q.items)
}

func (q *StringQueue) Enqueue(v string) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *StringQueue) Dequeue() (v string, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	UintQueue struct {
		items []uint
	}
)

//noinspection GoUnusedExportedFunction
func NewUintQueue() *UintQueue {
	q := new(UintQueue)
	q.items = make([]uint, 0, 0)
	return q
}

func (q *UintQueue) Count() int {
	return len(q.items)
}

func (q *UintQueue) Enqueue(v uint) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *UintQueue) Dequeue() (v uint, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Uint16Queue struct {
		items []uint16
	}
)

//noinspection GoUnusedExportedFunction
func NewUint16Queue() *Uint16Queue {
	q := new(Uint16Queue)
	q.items = make([]uint16, 0, 0)
	return q
}

func (q *Uint16Queue) Count() int {
	return len(q.items)
}

func (q *Uint16Queue) Enqueue(v uint16) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Uint16Queue) Dequeue() (v uint16, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Uint32Queue struct {
		items []uint32
	}
)

//noinspection GoUnusedExportedFunction
func NewUint32Queue() *Uint32Queue {
	q := new(Uint32Queue)
	q.items = make([]uint32, 0, 0)
	return q
}

func (q *Uint32Queue) Count() int {
	return len(q.items)
}

func (q *Uint32Queue) Enqueue(v uint32) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Uint32Queue) Dequeue() (v uint32, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Uint64Queue struct {
		items []uint64
	}
)

//noinspection GoUnusedExportedFunction
func NewUint64Queue() *Uint64Queue {
	q := new(Uint64Queue)
	q.items = make([]uint64, 0, 0)
	return q
}

func (q *Uint64Queue) Count() int {
	return len(q.items)
}

func (q *Uint64Queue) Enqueue(v uint64) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Uint64Queue) Dequeue() (v uint64, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	Uint8Queue struct {
		items []uint8
	}
)

//noinspection GoUnusedExportedFunction
func NewUint8Queue() *Uint8Queue {
	q := new(Uint8Queue)
	q.items = make([]uint8, 0, 0)
	return q
}

func (q *Uint8Queue) Count() int {
	return len(q.items)
}

func (q *Uint8Queue) Enqueue(v uint8) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *Uint8Queue) Dequeue() (v uint8, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}

type (
	UintptrQueue struct {
		items []uintptr
	}
)

//noinspection GoUnusedExportedFunction
func NewUintptrQueue() *UintptrQueue {
	q := new(UintptrQueue)
	q.items = make([]uintptr, 0, 0)
	return q
}

func (q *UintptrQueue) Count() int {
	return len(q.items)
}

func (q *UintptrQueue) Enqueue(v uintptr) (ok bool) {
	q.items = append(q.items, v)
	ok = true
	return
}

func (q *UintptrQueue) Dequeue() (v uintptr, ok bool) {
	if q.Count() == 0 {
		ok = false
		return
	}

	v = q.items[0]
	if q.Count() == 0 {
		ok = true
		return
	}

	q.items = q.items[1:]
	ok = true

	return
}
