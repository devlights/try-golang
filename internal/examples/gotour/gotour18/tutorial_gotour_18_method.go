package gotour18

import "fmt"

type (
	point struct {
		x, y int
	}

	// int の 拡張型。C#などの拡張メソッドな感じを実現したい場合は
	// このように既存型の別名をつけて、それにメソッドを付与する。
	myInt int
)

// point 型の コンストラクタ 関数です
func newPoint(x, y int) *point {
	return &point{x, y}
}

// Change -- 自身の状態を指定された値に変更します
func (p *point) Change(x, y int) {
	p.x, p.y = x, y
}

// fmt.Stringer インターフェースの実装です
func (p *point) String() string {
	return fmt.Sprintf("X:%v\tY:%v", p.x, p.y)
}

// Double -- 2 倍
func (i *myInt) Double() myInt {
	return (*i) * 2
}

// ToInt -- int に変換
func (i *myInt) ToInt() int {
	return int(*i)
}

func (i *myInt) String() string {
	val := int(*i)
	return fmt.Sprintf("myInt: %v", val)
}

// Method は、 Tour of Go - Methods (https://tour.golang.org/methods/1) の サンプルです。
func Method() error {
	// ------------------------------------------------------------
	// Go言語のメソッド
	// Go言語には、クラスの仕組みは無いが、型にメソッドを定義することができる。
	// 感じ的には、Pythonに似ていて、レシーバを明示的に定義する必要がある。
	// レシーバは、funcキーワードと関数名の間に定義する。
	// レシーバの型を、実体にするかポインタにするかで挙動が変わることがある。
	// 通常は、レシーバが持つ状態を変化させることが多くなるため
	// ポインタレシーバにすることが多い。
	//
	// ポインタレシーバにしている場合、普通であれば、その型のポインタの場合のみ
	// 利用できるメソッドという意味になるが、Go言語では利便性のために
	// 変数の状態で、ポインタレシーバを要求するメソッドを呼び出した場合でも
	// メソッド側でポインタレシーバが自動的に呼び出されるようになっている。
	// つまり、呼び出そうとしているメソッドがポインタレシーバを要求しているかどうかは
	// 気にしなくて良くなっている.
	//   内部的には、 変数p がポインタレシーバを要求するメソッドを呼び出した場合に
	//   (&p).xxxx() として解釈される。
	//
	// 同じ理屈が変数レシーバの場合にも適用される。
	// つまり、ポインタの状態で変数レシーバを要求するメソッドを呼び出した場合
	// 内部的に (*p).xxxx() と解釈される。
	//
	// ポインタレシーバが使われる大きな理由は以下の2つ。
	// 1. メソッドがレシーバが指す先の変数を変更するため
	// 2. メソッド呼び出しの際に変数のコピーを避けるため。
	//    変数レシーバの場合は呼び出しの度に変数のコピーが発生するため
	//    巨大な構造体の場合にオーバーヘッドが大きい。
	//    ポインタレシーバの場合は、ポインタをコピーするだけとなる。
	//
	// 一般的には、変数レシーバ、または、ポインタレシーバのどちらかで
	// 全てのメソッドを定義するべきあり、混在させるべきではない。
	// 混在させている場合、インターフェースを利用した際にちょっと面倒になるため。
	// ------------------------------------------------------------
	var (
		p *point
		i myInt
	)

	p = newPoint(10, 20)
	fmt.Println(p) // 内部で fmt.Stringer インターフェースのメソッドが呼ばれる

	p.Change(30, 40)
	fmt.Println(p)

	i = 100
	fmt.Println(i)

	i = i.Double() // 変数の状態で呼び出しているが、Go言語側で (&i).Double() と解釈される.
	fmt.Println(i)

	i2 := i.ToInt()
	fmt.Printf("i[type:%T val:%v] i2[type:%T val:%v]\n", i, i, i2, i2)

	return nil
}
